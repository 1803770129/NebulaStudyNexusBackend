# 闭包（Closure）完全指南

## 一、什么是闭包

### 1.1 定义

闭包是指**有权访问另一个函数作用域中变量的函数**。

简单说：**函数 + 函数能够访问的外部变量 = 闭包**

```javascript
function outer() {
  const name = 'closure'  // 外部函数的变量
  
  function inner() {
    console.log(name)     // 内部函数访问外部变量
  }
  
  return inner
}

const fn = outer()  // outer 执行完毕
fn()  // 'closure' - 仍然能访问 name！
```

### 1.2 闭包的形成条件

1. 函数嵌套
2. 内部函数引用外部函数的变量
3. 内部函数被返回或传递到外部

```javascript
// 条件1：函数嵌套
function outer() {
  const x = 10
  
  // 条件2：内部函数引用外部变量
  function inner() {
    console.log(x)
  }
  
  // 条件3：内部函数被返回
  return inner
}
```

### 1.3 闭包的本质

```javascript
// 正常情况：函数执行完毕，局部变量被销毁
function normal() {
  const x = 10
  console.log(x)
}
normal()  // x 被销毁

// 闭包情况：外部函数执行完毕，但变量被内部函数引用，不会被销毁
function outer() {
  const x = 10
  return function() {
    console.log(x)  // x 被引用，不会被销毁
  }
}
const fn = outer()
fn()  // 10 - x 仍然存在！
```

**本质**：闭包让函数"记住"了它被创建时的环境（词法作用域）。

---

## 二、闭包的原理

### 2.1 作用域链

```javascript
const global = 'global'

function outer() {
  const outerVar = 'outer'
  
  function inner() {
    const innerVar = 'inner'
    console.log(innerVar)  // 当前作用域
    console.log(outerVar)  // 外层作用域
    console.log(global)    // 全局作用域
  }
  
  return inner
}

// 作用域链：inner → outer → global
```

```
┌─────────────────────────────────┐
│         Global Scope            │
│  global = 'global'              │
│  ┌───────────────────────────┐  │
│  │      outer Scope          │  │
│  │  outerVar = 'outer'       │  │
│  │  ┌─────────────────────┐  │  │
│  │  │    inner Scope      │  │  │
│  │  │  innerVar = 'inner' │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

### 2.2 词法作用域（静态作用域）

JavaScript 使用**词法作用域**，函数的作用域在**定义时**确定，而不是调用时。

```javascript
const x = 10

function foo() {
  console.log(x)  // 定义时 x = 10
}

function bar() {
  const x = 20
  foo()  // 输出 10，不是 20
}

bar()  // 10
```

### 2.3 执行上下文与闭包

```javascript
function outer() {
  const x = 10
  
  return function inner() {
    console.log(x)
  }
}

const fn = outer()

// 执行过程：
// 1. outer() 执行，创建 outer 执行上下文
// 2. outer 执行上下文中：x = 10，inner 函数被创建
// 3. inner 函数的 [[Scope]] 保存了 outer 的变量环境
// 4. outer() 返回 inner，outer 执行上下文出栈
// 5. 但 inner 的 [[Scope]] 仍然引用着 x，所以 x 不会被回收
// 6. fn() 执行时，通过 [[Scope]] 找到 x
```


---

## 三、闭包的应用场景

### 3.1 数据私有化（模拟私有变量）

```javascript
// 创建私有变量，外部无法直接访问
function createCounter() {
  let count = 0  // 私有变量
  
  return {
    increment() {
      count++
      return count
    },
    decrement() {
      count--
      return count
    },
    getCount() {
      return count
    }
  }
}

const counter = createCounter()
console.log(counter.getCount())  // 0
counter.increment()
counter.increment()
console.log(counter.getCount())  // 2

// 无法直接访问 count
console.log(counter.count)  // undefined
```

### 3.2 模块模式

```javascript
const Module = (function() {
  // 私有变量
  let privateVar = 0
  const privateMethod = () => {
    return privateVar
  }
  
  // 公开接口
  return {
    publicMethod() {
      privateVar++
      return privateMethod()
    },
    getPrivate() {
      return privateVar
    }
  }
})()

Module.publicMethod()  // 1
Module.getPrivate()    // 1
Module.privateVar      // undefined（无法访问）
```

### 3.3 函数柯里化

```javascript
// 普通函数
function add(a, b, c) {
  return a + b + c
}

// 柯里化版本
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs))
    }
  }
}

const curriedAdd = curry(add)
curriedAdd(1)(2)(3)    // 6
curriedAdd(1, 2)(3)    // 6
curriedAdd(1)(2, 3)    // 6

// 实际应用：参数复用
const add10 = curriedAdd(10)
add10(5)(3)  // 18
add10(1)(2)  // 13
```

### 3.4 防抖（Debounce）

```javascript
function debounce(fn, delay) {
  let timer = null  // 闭包保存 timer
  
  return function(...args) {
    const context = this
    
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(context, args)
    }, delay)
  }
}

// 使用
const handleInput = debounce(function(e) {
  console.log('搜索:', e.target.value)
}, 500)

input.addEventListener('input', handleInput)
```

### 3.5 节流（Throttle）

```javascript
function throttle(fn, delay) {
  let lastTime = 0  // 闭包保存上次执行时间
  
  return function(...args) {
    const now = Date.now()
    
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用
const handleScroll = throttle(function() {
  console.log('滚动位置:', window.scrollY)
}, 200)

window.addEventListener('scroll', handleScroll)
```

### 3.6 缓存（Memoization）

```javascript
function memoize(fn) {
  const cache = {}  // 闭包保存缓存
  
  return function(...args) {
    const key = JSON.stringify(args)
    
    if (cache[key] !== undefined) {
      console.log('从缓存获取')
      return cache[key]
    }
    
    console.log('计算结果')
    const result = fn.apply(this, args)
    cache[key] = result
    return result
  }
}

// 使用
const fibonacci = memoize(function(n) {
  if (n <= 1) return n
  return fibonacci(n - 1) + fibonacci(n - 2)
})

fibonacci(40)  // 第一次计算
fibonacci(40)  // 从缓存获取
```

### 3.7 单例模式

```javascript
const Singleton = (function() {
  let instance = null  // 闭包保存实例
  
  function createInstance() {
    return {
      name: 'Singleton',
      getData() {
        return 'data'
      }
    }
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance()
      }
      return instance
    }
  }
})()

const a = Singleton.getInstance()
const b = Singleton.getInstance()
console.log(a === b)  // true
```

### 3.8 事件监听器中保持状态

```javascript
function setupButton(buttonId) {
  let clickCount = 0  // 闭包保存点击次数
  
  const button = document.getElementById(buttonId)
  
  button.addEventListener('click', function() {
    clickCount++
    console.log(`点击了 ${clickCount} 次`)
  })
}

setupButton('myButton')
// 每次点击都会累加，因为 clickCount 被闭包保存
```

### 3.9 迭代器

```javascript
function createIterator(arr) {
  let index = 0  // 闭包保存当前索引
  
  return {
    next() {
      if (index < arr.length) {
        return { value: arr[index++], done: false }
      }
      return { value: undefined, done: true }
    },
    reset() {
      index = 0
    }
  }
}

const iterator = createIterator([1, 2, 3])
iterator.next()  // { value: 1, done: false }
iterator.next()  // { value: 2, done: false }
iterator.next()  // { value: 3, done: false }
iterator.next()  // { value: undefined, done: true }
```

---

## 四、闭包的问题与解决

### 4.1 内存泄漏

```javascript
// 问题：闭包会阻止垃圾回收
function createClosure() {
  const largeData = new Array(1000000).fill('x')  // 大数据
  
  return function() {
    console.log(largeData.length)
  }
}

let closure = createClosure()
// largeData 无法被回收，因为 closure 引用着它

// 解决：手动释放
closure = null  // 解除引用，允许垃圾回收
```

### 4.2 循环中的闭包问题

```javascript
// 问题：经典的循环闭包问题
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100)
}
// 输出：3, 3, 3（不是 0, 1, 2）

// 原因：var 没有块级作用域，循环结束后 i = 3
// 所有 setTimeout 回调共享同一个 i
```

**解决方案**：

```javascript
// 方案1：使用 let（推荐）
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100)
}
// 输出：0, 1, 2
// let 有块级作用域，每次循环都创建新的 i

// 方案2：使用 IIFE 创建闭包
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j)
    }, 100)
  })(i)
}
// 输出：0, 1, 2
// 每次循环都创建新的作用域，j 是当前 i 的副本

// 方案3：使用 setTimeout 第三个参数
for (var i = 0; i < 3; i++) {
  setTimeout(function(j) {
    console.log(j)
  }, 100, i)
}
// 输出：0, 1, 2

// 方案4：使用 bind
for (var i = 0; i < 3; i++) {
  setTimeout(function(j) {
    console.log(j)
  }.bind(null, i), 100)
}
// 输出：0, 1, 2
```

### 4.3 this 指向问题

```javascript
const obj = {
  name: 'obj',
  getName: function() {
    // 这里的 this 指向 obj
    return function() {
      // 这里的 this 指向 window（或 undefined）
      console.log(this.name)
    }
  }
}

obj.getName()()  // undefined

// 解决方案1：保存 this
const obj1 = {
  name: 'obj',
  getName: function() {
    const self = this  // 保存 this
    return function() {
      console.log(self.name)
    }
  }
}
obj1.getName()()  // 'obj'

// 解决方案2：箭头函数
const obj2 = {
  name: 'obj',
  getName: function() {
    return () => {
      console.log(this.name)  // 箭头函数继承外层 this
    }
  }
}
obj2.getName()()  // 'obj'

// 解决方案3：bind
const obj3 = {
  name: 'obj',
  getName: function() {
    return function() {
      console.log(this.name)
    }.bind(this)
  }
}
obj3.getName()()  // 'obj'
```


---

## 五、面试高频题

### Q1: 什么是闭包？

**答案**：
闭包是指有权访问另一个函数作用域中变量的函数。当内部函数引用了外部函数的变量，并且内部函数被返回或传递到外部时，就形成了闭包。

```javascript
function outer() {
  const x = 10
  return function inner() {
    console.log(x)  // 访问外部变量
  }
}
const fn = outer()
fn()  // 10
```

### Q2: 闭包的作用是什么？

**答案**：
1. **数据私有化**：创建私有变量，外部无法直接访问
2. **状态保持**：让函数"记住"之前的状态
3. **模块化**：实现模块模式，封装私有成员
4. **函数工厂**：创建特定功能的函数

### Q3: 闭包的缺点是什么？

**答案**：
1. **内存占用**：闭包会使变量一直保存在内存中，不会被垃圾回收
2. **内存泄漏**：如果不正确使用，可能导致内存泄漏
3. **性能影响**：过度使用闭包可能影响性能

**解决方法**：
- 及时解除引用（设为 null）
- 避免在循环中创建大量闭包
- 使用完毕后手动清理

### Q4: 输出题

```javascript
// 题目1
function fn() {
  var arr = []
  for (var i = 0; i < 3; i++) {
    arr[i] = function() {
      return i
    }
  }
  return arr
}

var result = fn()
console.log(result[0]())  // ?
console.log(result[1]())  // ?
console.log(result[2]())  // ?

// 答案：3, 3, 3
// 原因：var 没有块级作用域，三个函数共享同一个 i
```

```javascript
// 题目2：如何修改让输出 0, 1, 2？

// 方法1：使用 let
function fn() {
  var arr = []
  for (let i = 0; i < 3; i++) {
    arr[i] = function() {
      return i
    }
  }
  return arr
}

// 方法2：使用 IIFE
function fn() {
  var arr = []
  for (var i = 0; i < 3; i++) {
    arr[i] = (function(j) {
      return function() {
        return j
      }
    })(i)
  }
  return arr
}
```

```javascript
// 题目3
var a = 10
function foo() {
  console.log(a)
}

function bar() {
  var a = 20
  foo()
}

bar()  // ?

// 答案：10
// 原因：JavaScript 是词法作用域，foo 定义时 a = 10
```

```javascript
// 题目4
function outer() {
  var x = 10
  
  function inner() {
    x++
    console.log(x)
  }
  
  return inner
}

var fn1 = outer()
var fn2 = outer()

fn1()  // ?
fn1()  // ?
fn2()  // ?

// 答案：11, 12, 11
// 原因：fn1 和 fn2 是两个独立的闭包，各自有独立的 x
```

```javascript
// 题目5
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i)
  }, i * 1000)
}

// 输出：每隔1秒输出一个 5，共5个
// 0秒后：5
// 1秒后：5
// 2秒后：5
// 3秒后：5
// 4秒后：5
```

```javascript
// 题目6
function createFunctions() {
  var result = []
  
  for (var i = 0; i < 3; i++) {
    result.push(function() {
      console.log(i)
    })
  }
  
  return result
}

var funcs = createFunctions()
funcs[0]()  // 3
funcs[1]()  // 3
funcs[2]()  // 3

// 如何修改？
function createFunctions() {
  var result = []
  
  for (var i = 0; i < 3; i++) {
    result.push((function(j) {
      return function() {
        console.log(j)
      }
    })(i))
  }
  
  return result
}
// 输出：0, 1, 2
```

### Q5: 实现一个 once 函数

```javascript
// 让函数只执行一次
function once(fn) {
  let called = false
  let result
  
  return function(...args) {
    if (!called) {
      called = true
      result = fn.apply(this, args)
    }
    return result
  }
}

// 使用
const initialize = once(function() {
  console.log('初始化')
  return 'done'
})

initialize()  // '初始化'，返回 'done'
initialize()  // 不执行，返回 'done'
initialize()  // 不执行，返回 'done'
```

### Q6: 实现一个计数器

```javascript
function createCounter(initialValue = 0) {
  let count = initialValue
  
  return {
    increment() { return ++count },
    decrement() { return --count },
    reset() { count = initialValue; return count },
    getCount() { return count }
  }
}

const counter = createCounter(10)
counter.increment()  // 11
counter.increment()  // 12
counter.decrement()  // 11
counter.reset()      // 10
```

---

## 六、闭包与垃圾回收

### 6.1 垃圾回收机制

```javascript
// 正常情况：函数执行完毕，局部变量被回收
function normal() {
  const obj = { data: 'large data' }
  // 函数执行完毕，obj 被回收
}

// 闭包情况：变量被引用，不会被回收
function closure() {
  const obj = { data: 'large data' }
  return function() {
    console.log(obj.data)
  }
}

const fn = closure()
// obj 不会被回收，因为 fn 引用着它
```

### 6.2 如何避免内存泄漏

```javascript
// 1. 及时解除引用
let fn = closure()
fn()
fn = null  // 解除引用

// 2. 避免不必要的闭包
// 不好
function bad() {
  const largeData = new Array(1000000)
  return function() {
    // 即使不使用 largeData，它也不会被回收
    console.log('hello')
  }
}

// 好
function good() {
  const largeData = new Array(1000000)
  processData(largeData)  // 处理数据
  
  return function() {
    console.log('hello')  // 不引用 largeData
  }
}

// 3. 使用 WeakMap/WeakSet
const cache = new WeakMap()  // 弱引用，不阻止垃圾回收

function memoize(fn) {
  return function(obj) {
    if (cache.has(obj)) {
      return cache.get(obj)
    }
    const result = fn(obj)
    cache.set(obj, result)
    return result
  }
}
```

---

## 七、总结

### 闭包的核心概念

1. **定义**：函数 + 函数能访问的外部变量
2. **形成条件**：函数嵌套 + 内部函数引用外部变量 + 内部函数被返回
3. **本质**：让函数"记住"创建时的词法环境

### 闭包的应用

| 应用场景 | 说明 |
|---------|------|
| 数据私有化 | 创建私有变量 |
| 模块模式 | 封装私有成员 |
| 柯里化 | 参数复用 |
| 防抖/节流 | 保存定时器/时间戳 |
| 缓存 | 保存计算结果 |
| 单例模式 | 保存唯一实例 |
| 迭代器 | 保存当前索引 |

### 注意事项

1. **内存管理**：及时解除不需要的闭包引用
2. **循环问题**：使用 let 或 IIFE 解决
3. **this 问题**：使用箭头函数或保存 this
4. **性能考虑**：避免过度使用闭包
