## 二、生命周期篇

### 2.1 应用生命周期

**Q6: App 的生命周期有哪些？执行顺序是什么？**

```javascript
App({
  // 小程序初始化完成（全局只触发一次）
  onLaunch(options) {
    console.log('onLaunch', options);
    // 常用于：获取用户信息、检查登录状态、初始化全局数据
  },

  // 小程序启动或从后台进入前台
  onShow(options) {
    console.log('onShow', options);
    // 常用于：刷新数据、恢复状态
  },

  // 小程序从前台进入后台
  onHide() {
    console.log('onHide');
    // 常用于：保存数据、暂停音视频
  },

  // 小程序发生脚本错误或 API 调用失败
  onError(error) {
    console.log('onError', error);
    // 常用于：错误上报
  },

  // 页面不存在时触发
  onPageNotFound(options) {
    wx.redirectTo({ url: '/pages/404/index' });
  },

  // 未处理的 Promise 拒绝
  onUnhandledRejection(res) {
    console.log('unhandledRejection', res.reason);
  },
});
```
### 2.2 页面生命周期

**Q7: Page 的生命周期有哪些？执行顺序是什么？**

```javascript
Page({
  data: {
    message: 'Hello'
  },

  // 页面加载（只触发一次）
  onLoad(options) {
    console.log('onLoad', options);
    // 常用于：获取页面参数、请求初始数据
  },

  // 页面显示（每次显示都触发）
  onShow() {
    console.log('onShow');
    // 常用于：刷新数据
  },

  // 页面初次渲染完成（只触发一次）
  onReady() {
    console.log('onReady');
    // 常用于：获取节点信息、操作 canvas
  },

  // 页面隐藏
  onHide() {
    console.log('onHide');
    // 常用于：暂停定时器
  },

  // 页面卸载
  onUnload() {
    console.log('onUnload');
    // 常用于：清理定时器、取消监听
  },

  // 下拉刷新
  onPullDownRefresh() {
    // 需要在 json 中开启 enablePullDownRefresh
    this.loadData().then(() => {
      wx.stopPullDownRefresh();
    });
  },

  // 上拉触底
  onReachBottom() {
    this.loadMore();
  },

  // 页面滚动
  onPageScroll(e) {
    console.log('scrollTop:', e.scrollTop);
  },

  // 分享给朋友
  onShareAppMessage() {
    return {
      title: '分享标题',
      path: '/pages/index/index',
      imageUrl: '/static/share.png'
    };
  },

  // 分享到朋友圈
  onShareTimeline() {
    return {
      title: '分享标题',
      query: 'id=123'
    };
  },
});
```
### 2.3 组件生命周期

**Q8: Component 的生命周期有哪些？**

```javascript
Component({
  lifetimes: {
    // 组件实例被创建
    created() {
      console.log('created');
      // 此时还不能调用 setData
    },

    // 组件实例进入页面节点树
    attached() {
      console.log('attached');
      // 常用于：初始化数据
    },

    // 组件在视图层布局完成
    ready() {
      console.log('ready');
      // 常用于：获取节点信息
    },

    // 组件实例被移动到节点树另一个位置
    moved() {
      console.log('moved');
    },

    // 组件实例被从页面节点树移除
    detached() {
      console.log('detached');
      // 常用于：清理工作
    },

    // 组件发生错误
    error(err) {
      console.log('error', err);
    },
  },

  // 组件所在页面的生命周期
  pageLifetimes: {
    show() {
      console.log('page show');
    },
    hide() {
      console.log('page hide');
    },
    resize(size) {
      console.log('page resize', size);
    },
  },
});
```

### 3.2 setData 机制

**Q12: setData 的工作原理是什么？如何优化？**

A: setData 是小程序中更新视图的唯一方式。

### 3.3 事件系统

**Q13: 小程序的事件类型有哪些？**

```html
<!-- 冒泡事件：bind -->
<view bindtap="handleTap">点击</view>

<!-- 非冒泡事件：catch（阻止冒泡） -->
<view catchtap="handleTap">点击不冒泡</view>

<!-- 互斥事件：mut-bind（多个节点只触发一个） -->
<view mut-bind:tap="handleTap">互斥点击</view>

<!-- 捕获阶段：capture-bind / capture-catch -->
<view capture-bind:tap="handleCapture">捕获</view>
```
**Q14: 如何传递参数给事件处理函数？**

```html
<!-- 通过 data-* 传参 -->
<view 
  data-id="{{item.id}}" 
  data-name="{{item.name}}"
  bindtap="handleTap"
>
  点击
</view>
```

```javascript
Page({
  handleTap(e) {
    // 获取参数
    const { id, name } = e.currentTarget.dataset;
    console.log(id, name);
    
    // e.target vs e.currentTarget
    // target: 触发事件的源组件
    // currentTarget: 绑定事件的当前组件
  }
});
```

## 四、路由与导航篇

**Q15: 小程序的路由方式有哪些？区别是什么？**

| API | 说明 | 页面栈变化 | 触发生命周期 |
|-----|------|-----------|-------------|
| `navigateTo` | 保留当前页，跳转新页 | 入栈 | 新页面 onLoad |
| `redirectTo` | 关闭当前页，跳转新页 | 替换栈顶 | 当前 onUnload，新页面 onLoad |
| `switchTab` | 跳转 tabBar 页面 | 清空非 tab 页 | 目标页 onShow |
| `reLaunch` | 关闭所有页，打开新页 | 清空重建 | 新页面 onLoad |
| `navigateBack` | 返回上一页 | 出栈 | 当前 onUnload，上页 onShow |

**Q16: 页面栈的限制是什么？如何处理？**
A: 小程序页面栈最多 10 层。
使用 redirectTo 替代 navigateTo

## 五、组件化开发篇

**Q17: 如何创建和使用自定义组件？**

```javascript
// components/my-button/index.js
Component({
  // 组件属性
  properties: {
    text: {
      type: String,
      value: '按钮',
    },
    type: {
      type: String,
      value: 'default', // default | primary | danger
    },
    disabled: {
      type: Boolean,
      value: false,
    },
    loading: Boolean, // 简写
  },

  // 组件内部数据
  data: {
    innerCount: 0,
  },

  // 组件方法
  methods: {
    handleTap() {
      if (this.properties.disabled) return;
      this.triggerEvent('click', { count: this.data.innerCount });
    },
  },

  // 数据监听器
  observers: {
    'text, type': function(text, type) {
      console.log('属性变化', text, type);
    },
    'obj.**': function(obj) {
      // 监听对象所有属性
    },
  },
});
```

```html
<!-- components/my-button/index.wxml -->
<button 
  class="my-btn {{type}}" 
  disabled="{{disabled}}"
  loading="{{loading}}"
  bindtap="handleTap"
>
  {{text}}
</button>
```

```json
// 页面 json 中引用
{
  "usingComponents": {
    "my-button": "/components/my-button/index"
  }
}
```

```html
<!-- 页面中使用 -->
<my-button 
  text="提交" 
  type="primary" 
  bind:click="handleSubmit"
/>
```

**Q18: 组件间通信方式有哪些？**

```javascript
// 1. 父传子：properties
// 父组件
<child-comp name="{{userName}}" />

// 子组件
Component({
  properties: {
    name: String
  }
});

// 2. 子传父：triggerEvent
// 子组件
this.triggerEvent('change', { value: 'new value' }, {
  bubbles: true,      // 是否冒泡
  composed: true,     // 是否穿越组件边界
  capturePhase: false // 是否在捕获阶段触发
});

// 父组件
<child-comp bind:change="handleChange" />

// 3. 获取组件实例
// 父组件获取子组件
this.selectComponent('#child-id').doSomething();

// 4. 全局状态（behaviors 或状态管理库）
const globalBehavior = Behavior({
  data: {
    globalData: {}
  },
  methods: {
    setGlobalData(data) {
      this.setData({ globalData: data });
    }
  }
});

// 5. 事件总线
const eventBus = {
  events: {},
  on(event, callback) {
    if (!this.events[event]) this.events[event] = [];
    this.events[event].push(callback);
  },
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(cb => cb(data));
    }
  },
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
};
```
## 六、网络请求篇

**Q20: wx.request 的使用和封装？**
Promise 封装

**Q21: 小程序网络请求的限制？**

- 必须使用 HTTPS（开发时可关闭校验）
- 域名需要在后台配置白名单
- 并发请求数限制（同时最多 10 个）
- 单个请求超时默认 60s
- 请求大小限制

## 八、登录与授权篇

```javascript
// 小程序端
async function login() {
  // 1. 获取 code
  const { code } = await wx.login();
  
  // 2. 发送 code 到后端
  const res = await request({
    url: '/api/login',
    method: 'POST',
    data: { code },
  });
  
  // 3. 保存 token
  wx.setStorageSync('token', res.token);
  
  return res;
}

// 检查登录状态
async function checkLogin() {
  const token = wx.getStorageSync('token');
  if (!token) return false;
  
  try {
    await wx.checkSession(); // 检查 session_key 是否过期
    return true;
  } catch {
    // session_key 过期，需要重新登录
    wx.removeStorageSync('token');
    return false;
  }
}
```

**Q25: 如何获取用户信息？**

```javascript
// 新版获取用户信息（需要用户主动点击）
// wxml
<button open-type="chooseAvatar" bindchooseavatar="onChooseAvatar">
  <image src="{{avatarUrl}}" />
</button>
<input type="nickname" placeholder="请输入昵称" bindinput="onInputNickname" />

// js
Page({
  data: {
    avatarUrl: '/static/default-avatar.png',
    nickname: '',
  },
  
  onChooseAvatar(e) {
    this.setData({ avatarUrl: e.detail.avatarUrl });
  },
  
  onInputNickname(e) {
    this.setData({ nickname: e.detail.value });
  },
});

// 获取手机号（需要企业认证）
<button open-type="getPhoneNumber" bindgetphonenumber="onGetPhone">
  获取手机号
</button>

onGetPhone(e) {
  if (e.detail.code) {
    // 发送 code 到后端解密
    request({
      url: '/api/phone',
      method: 'POST',
      data: { code: e.detail.code },
    });
  }
}
```

## 九、性能优化篇

**Q26: 小程序性能优化有哪些方面？**

### 9.1 启动性能优化

```javascript
// 1. 分包加载
// app.json
{
  "pages": ["pages/index/index"],
  "subpackages": [
    {
      "root": "packageA",
      "pages": ["pages/detail/index"]
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["packageA"]
    }
  }
}

// 2. 独立分包（可独立运行）
{
  "subpackages": [
    {
      "root": "packageB",
      "pages": ["pages/share/index"],
      "independent": true
    }
  ]
}

// 3. 按需注入
{
  "lazyCodeLoading": "requiredComponents"
}
```

## 十三、面试高频问答总结
### 进阶题

6. **如何优化小程序性能？** → 分包加载、减少 setData、虚拟列表、图片懒加载
7. **登录流程是怎样的？** → wx.login获取code → 后端换取openid → 返回自定义登录态
8. **如何实现组件通信？** → properties、triggerEvent、selectComponent、全局状态
9. **WXS 的作用？** → 运行在渲染层，减少通信开销，适合数据格式化和响应式交互
10. **分包加载的限制？** → 主包2MB、分包2MB、总包20MB

### 实战题

12. **如何实现支付功能？** → 后端获取支付参数 → wx.requestPayment
13. **如何处理图片上传？** → wx.chooseMedia + wx.uploadFile
15. **如何处理版本更新？** → wx.getUpdateManager

## 十四、微信支付专题

## 十四、微信支付专题

### 14.1 支付流程详解

**Q41: 微信小程序支付的完整流程是什么？**
用户下单
后端返回支付参数
前端调用wx.requestPayment，让用户确认支付，轮询查支付结果，返回订单页面更新状态

```
┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
│  小程序  │     │ 商户后端 │     │ 微信支付 │     │  微信   │
│         │     │         │     │  服务器  │     │  服务器  │
└────┬────┘     └────┬────┘     └────┬────┘     └────┬────┘
     │               │               │               │
     │ 1.下单请求    │               │               │
     │──────────────>│               │               │
     │               │               │               │
     │               │ 2.统一下单API │               │
     │               │──────────────>│               │
     │               │               │               │
     │               │ 3.返回prepay_id               │
     │               │<──────────────│               │
     │               │               │               │
     │ 4.返回支付参数 │               │               │
     │<──────────────│               │               │
     │               │               │               │
     │ 5.wx.requestPayment           │               │
     │──────────────────────────────────────────────>│
     │               │               │               │
     │ 6.用户确认支付 │               │               │
     │<──────────────────────────────────────────────│
     │               │               │               │
     │               │               │ 7.支付结果通知 │
     │               │<──────────────│               │
     │               │               │               │
     │ 8.查询支付结果 │               │               │
     │──────────────>│               │               │
     │               │               │               │
     │ 9.返回订单状态 │               │               │
     │<──────────────│               │               │
```

**关键步骤说明：**

1. **用户下单**：小程序调用后端创建订单接口
2. **统一下单**：后端调用微信支付统一下单 API
3. **获取 prepay_id**：微信返回预支付交易会话标识
4. **生成支付参数**：后端签名生成前端需要的支付参数
5. **调起支付**：小程序调用 wx.requestPayment
6. **用户支付**：用户在微信中完成支付
7. **异步通知**：微信通知商户后端支付结果
8. **查询结果**：小程序查询订单支付状态